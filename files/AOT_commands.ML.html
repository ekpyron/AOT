<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹AOT_commands.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹AOT_commands.ML›</h1>
</div>

<pre class="source"><span class="comment1">(*
This file contains modified parts of the Isabelle ML sources
which are distributed with Isabelle under the following conditions:

ISABELLE COPYRIGHT NOTICE, LICENCE AND DISCLAIMER.

Copyright (c) 1986-2021,
  University of Cambridge,
  Technische Universitaet Muenchen,
  and contributors.

  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

* Neither the name of the University of Cambridge or the Technische
Universitaet Muenchen nor the names of their contributors may be used
to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_item_by_name</span> <span class="entity">name</span> <span class="main">=</span> Option.map fst <span class="main">(</span>List.find <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">n</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">name</span><span class="main">)</span> <span class="entity">AOT_items</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_name_of_item</span> <span class="entity">id</span> <span class="main">=</span> Option.map snd <span class="main">(</span>List.find <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">AOT_items</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Sign_add_syntax</span> <span class="main">=</span> Sign.add_syntax <span class="comment1">(* Next Isabelle release: = Sign.syntax true *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_AOT_syntax</span> <span class="main">=</span> <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "show_AOT_syntax"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>
<span class="keyword2"><span class="keyword">local</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_map_translation</span> <span class="entity">b</span> <span class="main">(</span><span class="entity">name</span><span class="main">:</span>string<span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_AOT_syntax</span> <span class="main">=</span> <span class="entity">b</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">f</span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Match<span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AOT_syntax_print_translations</span> <span class="main">=</span>
  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">:</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">=&gt;</span>
       <span class="entity">AOT_map_translation</span> true <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AOT_syntax_typed_print_translations</span>
  <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">:</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term<span class="main">)</span> <span class="main">=&gt;</span>
         <span class="entity">AOT_map_translation</span> true <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">AOT_syntax_print_ast_translations</span>
  <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">:</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> Ast.ast list <span class="main">-&gt;</span> Ast.ast<span class="main">)</span> <span class="main">=&gt;</span>
         <span class="entity">AOT_map_translation</span> true <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="entity">f</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_get_item_number</span> <span class="entity">name</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> hd <span class="main">(</span>String.fields <span class="main">(</span>equal <span class="inner_quoted">#"["</span><span class="main">)</span> <span class="entity">name</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> String.fields <span class="main">(</span>equal <span class="inner_quoted">#":"</span><span class="main">)</span> <span class="entity">name</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">AOT_item_by_name</span> <span class="main">(</span>hd <span class="entity">name</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>SOME <span class="entity">id</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>
fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">sub</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str</span> <span class="main">=&gt;</span> <span class="entity">str</span> ^ <span class="inner_quoted">"."</span> ^ <span class="entity">sub</span><span class="main">)</span> <span class="main">(</span>tl <span class="entity">name</span><span class="main">)</span> <span class="main">(</span>Int.toString <span class="entity">id</span><span class="main">)</span>
<span class="main">)</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_print_item_number</span> <span class="main">(</span><span class="entity">name</span><span class="main">:</span>string<span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">AOT_get_item_number</span> <span class="entity">name</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">str</span> <span class="main">=&gt;</span> Pretty.writeln <span class="main">(</span>Pretty.str <span class="main">(</span><span class="inner_quoted">"PLM item number ("</span> ^ <span class="entity">str</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_AOT_print_rule</span> <span class="entity">AOTsyntax</span> <span class="entity">raw_rules</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span> Ast.head_of_rule <span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">r</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">asts</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_AOT_syntax</span> <span class="main">=</span> <span class="entity">AOTsyntax</span> <span class="keyword2"><span class="keyword">then</span></span> 
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">orig</span> <span class="main">=</span> <span class="main">(</span>Ast.mk_appl <span class="main">(</span>Ast.Constant <span class="entity">head</span><span class="main">)</span> <span class="entity">asts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">normalized</span> <span class="main">=</span> Ast.normalize <span class="entity">ctxt</span>
          <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">head'</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head</span> <span class="main">=</span> <span class="entity">head'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span><span class="entity">r</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">orig</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">orig</span> <span class="main">=</span> <span class="entity">normalized</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Match <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">normalized</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Match<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">raw_rules</span>
<span class="keyword2"><span class="keyword">in</span></span> Sign.print_ast_translation <span class="entity">rules</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">local</span></span>
         
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_pat</span> <span class="main">=</span>
  Scan.optional
    <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">(</span>›</span></span>
      |-- Parse.!!! <span class="main">(</span>Parse.inner_syntax Parse.name --|
     <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">)</span>›</span></span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">"logic"</span>
    -- Parse.inner_syntax Parse.string<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trans_arrow</span> <span class="entity">toks</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span><span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">↽</span>›</span></span> || <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword2">&lt;=</span>›</span></span><span class="main">)</span>
    &gt;&gt; K Syntax.Print_Rule<span class="main">)</span> <span class="entity">toks</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trans_line</span> <span class="main">=</span>
  <span class="entity">trans_pat</span> -- Parse.!!! <span class="main">(</span><span class="entity">trans_arrow</span> |-- <span class="entity">trans_pat</span><span class="main">)</span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_trans_rule</span> <span class="entity">AOTsyntax</span> <span class="entity">raw_rules</span> <span class="entity">thy</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapPair</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">f</span> <span class="entity">y</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">read_root</span> <span class="main">=</span> <span class="main">#</span><span class="inner_numeral">1</span> o dest_Type o
    Proof_Context.read_type_name <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> false<span class="main">}</span> <span class="entity">ctxt</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_rules</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mapPair</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">r</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span> <span class="main">=&gt;</span>
    <span class="main">(</span>Syntax_Phases.parse_ast_pattern <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">read_root</span> <span class="entity">r</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_rules</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="entity">add_AOT_print_rule</span> <span class="entity">AOTsyntax</span> <span class="entity">raw_rules</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span>
    <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_syntax_print_translations</span>›</span></span>
    <span class="inner_quoted">"add print translation rules for AOT syntax"</span>
    <span class="main">(</span>Scan.repeat1 <span class="entity">trans_line</span> &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">add_trans_rule</span> true<span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span>
    <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_no_syntax_print_translations</span>›</span></span>
    <span class="inner_quoted">"add AOT print translation rules for non-AOT syntax"</span>
    <span class="main">(</span>Scan.repeat1 <span class="entity">trans_line</span> &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">add_trans_rule</span> false<span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AOT_Theorems</span> <span class="main">=</span> <span class="entity">Named_Thms</span><span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "AOT"<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"AOT Theorems"</span>
<span class="main">)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AOT_Definitions</span> <span class="main">=</span> <span class="entity">Named_Thms</span><span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "AOT_defs"<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"AOT Definitions"</span>
<span class="main">)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AOT_ProofData</span> <span class="main">=</span> Proof_Data
<span class="main">(</span><span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> term option
 <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> NONE<span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_note_theorems</span> <span class="entity">thms</span> <span class="main">=</span> Local_Theory.background_theory
  <span class="main">(</span>Context.theory_map <span class="main">(</span>fold <span class="entity">AOT_Theorems.add_thm</span>
    <span class="main">(</span>map Drule.export_without_context <span class="main">(</span>flat <span class="entity">thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_note_definitions</span> <span class="entity">thms</span> <span class="main">=</span> Local_Theory.background_theory
  <span class="main">(</span>Context.theory_map <span class="main">(</span>fold <span class="entity">AOT_Definitions.add_thm</span>
    <span class="main">(</span>map Drule.export_without_context <span class="main">(</span>flat <span class="entity">thms</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AOT_DefinedConstants</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> Termtab.set
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Termtab.empty
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Termtab.merge <span class="main">(</span>K true<span class="main">)</span>
<span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_note_defined_constant</span> <span class="entity">const</span> <span class="main">=</span>
  Local_Theory.background_theory <span class="main">(</span>AOT_DefinedConstants.map <span class="main">(</span>Termtab.insert_set <span class="entity">const</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_read_prop</span> <span class="entity">nonterminal</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Config.put Syntax.root <span class="entity">nonterminal</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Syntax.parse_term <span class="entity">ctxt'</span> <span class="entity">prop</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> Term.fastype_of <span class="main">(</span>Syntax.check_term <span class="entity">ctxt'</span> <span class="entity">trm</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">typ</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">prop</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_read_term</span> <span class="entity">nonterminal</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Config.put Syntax.root <span class="entity">nonterminal</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Syntax.parse_term <span class="entity">ctxt'</span> <span class="entity">prop</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_check_prop</span> <span class="entity">nonterminal</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span>
  <span class="entity">AOT_read_prop</span> <span class="entity">nonterminal</span> <span class="entity">ctxt</span> <span class="entity">prop</span> |&gt; Syntax.check_prop <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">close_form</span> <span class="entity">t</span> <span class="main">=</span>
  fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="entity">HOLogic.mk_all</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">t</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_case_prod</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹case_prod›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="entity">remove_case_prod</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">remove_case_prod</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹case_unit›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="entity">remove_case_prod</span> <span class="entity">x</span>
  <span class="main">|</span> <span class="entity">remove_case_prod</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">,</span><span class="entity">remove_case_prod</span> <span class="entity">c</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">remove_case_prod</span> <span class="entity">x</span> <span class="main">=</span> <span class="entity">x</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_define_id</span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">str</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">,</span><span class="entity">trm</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnd_str</span> <span class="main">=</span> Binding.name_of <span class="entity">bnd</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">syn_typ</span> <span class="main">=</span> Syntax.parse_typ <span class="entity">ctxt</span> <span class="entity">str</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">remove_case_prod</span> <span class="entity">lhs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">remove_case_prod</span> <span class="entity">rhs</span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filter</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> not <span class="main">(</span><span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹case_prod›</span>
      <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹case_unit›</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>List.filter <span class="entity">filter</span> <span class="main">(</span>Term.add_consts <span class="entity">lhs</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="entity">const</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">const</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM
      <span class="main">(</span><span class="inner_quoted">"Expected a single constant on the LHS of the definition."</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">]</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">bnd_str</span>
    <span class="keyword1"><span class="keyword">orelse</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM <span class="main">(</span><span class="inner_quoted">"Left-hand side does not contain the definiens."</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">]</span><span class="main">)</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs_abs_vars</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.strip_abs <span class="entity">lhs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rhs_abs_vars</span><span class="main">,</span> <span class="entity">rhs_abs_body</span><span class="main">)</span> <span class="main">=</span> Term.strip_abs <span class="entity">rhs</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">lhs_abs_vars</span> <span class="main">=</span> <span class="entity">rhs_abs_vars</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM
    <span class="main">(</span><span class="inner_quoted">"Expected the LHS and RHS to abstract over the same free variables."</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">rhs_abs_body</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness</span> <span class="main">=</span> fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.absfree <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span>
    <span class="entity">lhs_abs_vars</span> <span class="entity">body</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness</span> <span class="main">=</span> Syntax.check_term <span class="entity">ctxt</span> <span class="entity">witness</span>

  <span class="comment1">(* Construct the choice specification theorem. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cname</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const_name</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vname</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Symbol_Pos.is_identifier <span class="entity">cname</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">cname</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"x"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_exists</span> <span class="main">(</span><span class="entity">vname</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">,</span>
          Term.abstract_over <span class="main">(</span>Const <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">trm</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cwitness</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">witness</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness_exI</span> <span class="main">=</span> Thm.instantiate'
        <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of_cterm <span class="entity">cwitness</span><span class="main">)</span><span class="main">]</span>
        <span class="main">[</span>NONE<span class="main">,</span>SOME <span class="entity">cwitness</span><span class="main">]</span> <span class="entity">exI</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span> <span class="main">=</span> <span class="main">[</span>
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_id_def<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_nondenoing<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_denotes_prod_def<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_denotes_unit_def<span class="antiquote">}</span></span></span><span class="main">,</span>
        <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> case_unit_Unity<span class="antiquote">}</span></span></span>
      <span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">trm</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
        resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">witness_exI</span><span class="main">]</span> <span class="inner_numeral">1</span>
        THEN <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> addsimps <span class="entity">simps</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match</span> <span class="main">=</span> Thm.match <span class="main">(</span>Thm.cprop_of <span class="entity">thm</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> Drule.instantiate_normalize <span class="entity">match</span> <span class="entity">thm</span> <span class="keyword2"><span class="keyword">end</span></span>

  <span class="comment1">(* Add the choice specification and cleanup and export the resulting theorem. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oldctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Local_Theory.background_theory_result <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">lthy</span> |&gt; Sign.add_consts <span class="main">[</span><span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">const_typ</span><span class="main">,</span>Mixfix.NoSyn<span class="main">)</span><span class="main">]</span> |&gt;
        <span class="entity">Sign_add_syntax</span> Syntax.mode_default <span class="main">[</span><span class="main">(</span><span class="entity">bnd_str</span><span class="main">,</span><span class="entity">syn_typ</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span><span class="main">]</span> |&gt;
        <span class="entity">add_AOT_print_rule</span> true <span class="main">[</span>
          <span class="main">(</span>Ast.Constant <span class="entity">bnd_str</span><span class="main">,</span> Ast.Constant <span class="main">(</span>Lexicon.mark_const <span class="entity">const_name</span><span class="main">)</span><span class="main">)</span>
        <span class="main">]</span>
     <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Choice_Specification.add_specification</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span><span class="entity">bnd_str</span><span class="main">,</span>false<span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">lthy</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span>
      |&gt; apsnd Drule.export_without_context |&gt; swap
     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span>Proof_Context.concealed <span class="entity">ctxt</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">ctxt</span> |&gt; Proof_Context.restore_naming <span class="entity">oldctxt</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_define_equiv</span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">str</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">,</span><span class="entity">trm</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnd_str</span> <span class="main">=</span> Binding.name_of <span class="entity">bnd</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">syn_typ</span> <span class="main">=</span> Syntax.parse_typ <span class="entity">ctxt</span> <span class="entity">str</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>Term.add_consts <span class="entity">lhs</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="entity">const</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">const</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM
      <span class="main">(</span><span class="inner_quoted">"Expected a single constant on the LHS of the definition."</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">]</span><span class="main">)</span>
  
  <span class="comment1">(* TODO: figure out how to properly compare the constant name with the binding *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const_name</span> <span class="main">=</span> Long_Name.base_name <span class="entity">bnd_str</span>
    <span class="keyword1"><span class="keyword">orelse</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM <span class="main">(</span><span class="inner_quoted">"Left-hand side does not contain the definiens."</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">]</span><span class="main">)</span>
  
  <span class="comment1">(* Construct a witness for the choice specification theorem. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> Term.add_frees <span class="entity">trm</span> <span class="main">[</span><span class="main">]</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">w</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Term.variant_frees <span class="entity">trm</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"w"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="entity">w</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">w</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unexpected."</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‹AOT_model_proposition_choice›</span> $
    Term.absfree <span class="entity">w</span> <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‹AOT_model_valid_in›</span> $ Free <span class="entity">w</span> $ <span class="entity">rhs</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness</span> <span class="main">=</span> fold_rev <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Term.absfree <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span><span class="main">)</span>
    <span class="main">(</span>List.rev <span class="entity">frees</span><span class="main">)</span> <span class="entity">witness</span>
  
  <span class="comment1">(* Construct the choice specification theorem. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cname</span> <span class="main">=</span> Long_Name.base_name <span class="entity">const_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vname</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Symbol_Pos.is_identifier <span class="entity">cname</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">cname</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"x"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> $ <span class="entity">HOLogic.mk_exists</span> <span class="main">(</span><span class="entity">vname</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">,</span>
        Term.abstract_over <span class="main">(</span>Const <span class="main">(</span><span class="entity">const_name</span><span class="main">,</span> <span class="entity">const_typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">close_form</span> <span class="entity">trm</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cwitness</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">witness</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">witness_exI</span> <span class="main">=</span> Thm.instantiate'
      <span class="main">[</span>SOME <span class="main">(</span>Thm.ctyp_of_cterm <span class="entity">cwitness</span><span class="main">)</span><span class="main">]</span>
      <span class="main">[</span>NONE<span class="main">,</span>SOME <span class="entity">cwitness</span><span class="main">]</span> <span class="entity">exI</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span> <span class="main">=</span> <span class="main">[</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_equiv_def<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> AOT_model_proposition_choice_simp<span class="antiquote">}</span></span></span>
    <span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">(</span>Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">trm</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
      resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">witness_exI</span><span class="main">]</span> <span class="inner_numeral">1</span>
      THEN <span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> addsimps <span class="entity">simps</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match</span> <span class="main">=</span> Thm.match <span class="main">(</span>Thm.cprop_of <span class="entity">thm</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Drule.instantiate_normalize <span class="entity">match</span> <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
  <span class="comment1">(* Add the choice specification and cleanup and export the resulting theorem. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">oldctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">thm</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Proof_Context.concealed <span class="entity">ctxt</span> |&gt;
    Local_Theory.background_theory_result <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">lthy</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_all</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">typ</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span>
       <span class="keyword2"><span class="keyword">let</span></span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> Thm.global_cterm_of <span class="entity">thy</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span><span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cT</span> <span class="main">=</span> Thm.global_ctyp_of <span class="entity">thy</span> <span class="entity">typ</span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec'</span> <span class="main">=</span> Thm.instantiate' <span class="main">[</span>SOME <span class="entity">cT</span><span class="main">]</span> <span class="main">[</span>NONE<span class="main">,</span> SOME <span class="entity">cv</span><span class="main">]</span> <span class="entity">spec</span>
       <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thm</span> RS <span class="entity">spec'</span> <span class="keyword2"><span class="keyword">end</span></span>
     <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_alls</span> <span class="entity">frees</span> <span class="main">(</span><span class="entity">thy</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">thy</span><span class="main">,</span> fold <span class="main">(</span><span class="entity">inst_all</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">frees</span> <span class="entity">thm</span><span class="main">)</span>
     <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lthy</span> <span class="main">=</span> <span class="entity">lthy</span> |&gt; Sign.add_consts <span class="main">[</span><span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">const_typ</span><span class="main">,</span>Mixfix.NoSyn<span class="main">)</span><span class="main">]</span> |&gt;
        <span class="entity">Sign_add_syntax</span> Syntax.mode_default <span class="main">[</span><span class="main">(</span><span class="entity">bnd_str</span><span class="main">,</span><span class="entity">syn_typ</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span><span class="main">]</span> |&gt;
        <span class="entity">add_AOT_print_rule</span> true <span class="main">[</span>
          <span class="main">(</span>Ast.Constant <span class="entity">bnd_str</span><span class="main">,</span> Ast.Constant <span class="main">(</span>Lexicon.mark_const <span class="entity">const_name</span><span class="main">)</span><span class="main">)</span>
        <span class="main">]</span>
     <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Choice_Specification.add_specification</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span><span class="entity">bnd_str</span><span class="main">,</span>false<span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">lthy</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span>
      |&gt; <span class="entity">remove_alls</span> <span class="entity">frees</span> |&gt; apsnd Drule.export_without_context |&gt; swap
     <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="entity">ctxt</span> |&gt; Proof_Context.restore_naming <span class="entity">oldctxt</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_define</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">str</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="entity">thmbind</span><span class="main">,</span><span class="entity">thmattrs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span><span class="entity">defprop</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnd_str</span> <span class="main">=</span> Binding.name_of <span class="entity">bnd</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">syn_typ</span> <span class="main">=</span> Syntax.parse_typ <span class="entity">ctxt</span> <span class="entity">str</span>

    <span class="comment1">(* Add a generic constant and the requested syntax to a temporary context. *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> Sign.add_consts <span class="main">[</span><span class="main">(</span><span class="entity">bnd</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span><span class="main">,</span> Mixfix.NoSyn<span class="main">)</span><span class="main">]</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy'</span> <span class="main">=</span> <span class="entity">Sign_add_syntax</span> Syntax.mode_default <span class="main">[</span><span class="main">(</span><span class="entity">bnd_str</span><span class="main">,</span><span class="entity">syn_typ</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span><span class="main">]</span> <span class="entity">thy'</span>
    <span class="comment1">(* Try to parse the definition using the temporary context. *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">AOT_check_prop</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span>
      <span class="main">(</span>Proof_Context.init_global <span class="entity">thy'</span><span class="main">)</span> <span class="entity">defprop</span>
    <span class="comment1">(* Extract lhs, rhs and the full definition from the parsed proposition
       and delegate. *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹HOL.Trueprop›</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ 
      <span class="main">(</span><span class="entity">trm</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> 
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹AOT_model_equiv_def›</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">AOT_define_equiv</span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">str</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">,</span><span class="entity">trm</span><span class="main">)</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹AOT_model_id_def›</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">AOT_define_id</span> <span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="entity">str</span><span class="main">,</span><span class="entity">mx</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span><span class="entity">rhs</span><span class="main">,</span><span class="entity">trm</span><span class="main">)</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM <span class="main">(</span><span class="inner_quoted">"Expected AOT definition."</span><span class="main">,</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Term.TERM <span class="main">(</span><span class="inner_quoted">"Expected AOT definition."</span><span class="main">,</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmbind</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Binding.is_empty <span class="entity">thmbind</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">bnd</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">thmbind</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_print_item_number</span> <span class="main">(</span>Binding.name_of <span class="entity">thmbind</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">ctxt</span> |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span><span class="entity">thmbind</span><span class="main">,</span> <span class="entity">thmattrs</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">)</span> |&gt; snd |&gt;
    <span class="entity">AOT_note_theorems</span> <span class="main">[</span><span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">]</span> |&gt; <span class="entity">AOT_note_definitions</span> <span class="main">[</span><span class="main">[</span><span class="entity">thm</span><span class="main">]</span><span class="main">]</span> |&gt;
    <span class="entity">AOT_note_defined_constant</span>
      <span class="main">(</span>Proof_Context.read_const <span class="main">{</span>proper<span class="main">=</span>true<span class="main">,</span>strict<span class="main">=</span>true<span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span>Binding.name_of <span class="entity">bnd</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="entity">Outer_Syntax.local_theory</span>
<span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">AOT_define</span><span class="antiquote">}</span></span></span>
<span class="inner_quoted">"AOT definition by equivalence."</span>
<span class="main">(</span>Parse.const_binding -- <span class="entity">Parse_Spec.opt_thm_name</span> <span class="inner_quoted">":"</span> -- Parse.prop &gt;&gt; <span class="entity">AOT_define</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="comment1">(* this is a stripped down version of Expression.read_statement
   that mainly replaces Syntax.parse_prop with AOT_read_prop
   and drops locale includes *)</span>
<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_type</span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>Logic.mk_type <span class="entity">T</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_propp</span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">pats</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Type.constraint propT <span class="entity">p</span><span class="main">,</span> <span class="entity">pats</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_type</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> Logic.dest_type <span class="entity">T</span>
  <span class="main">|</span> <span class="entity">dest_type</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unexpected."</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_propp</span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">pats</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">p</span><span class="main">,</span> <span class="entity">pats</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">finish_fixes</span> <span class="main">(</span><span class="entity">parms</span><span class="main">:</span> <span class="main">(</span>string * typ<span class="main">)</span> list<span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Binding.name_of <span class="entity">binding</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">binding</span><span class="main">,</span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">parms</span> <span class="entity">x</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">finish_elem</span> <span class="entity">parms</span> <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Element.Fixes</span> <span class="main">(</span><span class="entity">finish_fixes</span> <span class="entity">parms</span> <span class="entity">fixes</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">finish_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Constrains</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Element.Constrains</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">finish_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Assumes</span> <span class="entity">asms</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Element.Assumes</span> <span class="entity">asms</span>
  <span class="main">|</span> <span class="entity">finish_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Defines</span> <span class="entity">defs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Element.Defines</span> <span class="entity">defs</span>
  <span class="main">|</span> <span class="entity">finish_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">elem</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Element.Notes</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">elem</span>
  <span class="main">|</span> <span class="entity">finish_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">elem</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Element.Lazy_Notes</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">elem</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> #&gt; the_list #&gt; map <span class="entity">mk_type</span><span class="main">)</span> <span class="entity">fixes</span>
  <span class="main">|</span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Constrains</span> <span class="entity">csts</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> #&gt; single #&gt; map <span class="entity">mk_type</span><span class="main">)</span> <span class="entity">csts</span>
  <span class="main">|</span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Assumes</span> <span class="entity">asms</span><span class="main">)</span> <span class="main">=</span> map <span class="main">(</span><span class="main">#</span><span class="inner_numeral">2</span> #&gt; map <span class="entity">mk_propp</span><span class="main">)</span> <span class="entity">asms</span>
  <span class="main">|</span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Defines</span> <span class="entity">defs</span><span class="main">)</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ps</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">mk_propp</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ps</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">defs</span>
  <span class="main">|</span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Notes</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">extract_elem</span> <span class="main">(</span><span class="entity">Element.Lazy_Notes</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">,</span> <span class="entity">css</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">fixes</span> ~~ <span class="entity">css</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">cs</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">cs</span> |&gt; map <span class="entity">dest_type</span> |&gt; try hd<span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">Element.Fixes</span>
  <span class="main">|</span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">Element.Constrains</span> <span class="entity">csts</span><span class="main">,</span> <span class="entity">css</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">csts</span> ~~ <span class="entity">css</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">cs</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">cs</span> |&gt; map <span class="entity">dest_type</span> |&gt; hd<span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">Element.Constrains</span>
  <span class="main">|</span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">Element.Assumes</span> <span class="entity">asms</span><span class="main">,</span> <span class="entity">css</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">asms</span> ~~ <span class="entity">css</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">cs</span><span class="main">)</span> <span class="main">=&gt;</span>
         <span class="main">(</span><span class="entity">b</span><span class="main">,</span> map <span class="entity">dest_propp</span> <span class="entity">cs</span><span class="main">)</span><span class="main">)</span> |&gt; <span class="entity">Element.Assumes</span>
  <span class="main">|</span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">Element.Defines</span> <span class="entity">defs</span><span class="main">,</span> <span class="entity">css</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">defs</span> ~~ <span class="entity">css</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">c</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">dest_propp</span> <span class="entity">c</span><span class="main">)</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unexpected"</span><span class="main">)</span> |&gt; <span class="entity">Element.Defines</span>
  <span class="main">|</span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">elem</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Element.Notes</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">elem</span>
  <span class="main">|</span> <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">elem</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="entity">Element.Lazy_Notes</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">elem</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pats</span><span class="main">)</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">t</span> :: <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Proof_Context.augment <span class="entity">t</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">t</span><span class="main">,</span> Syntax.check_props
            <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_pattern <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">pats</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">prep</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unexpected"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check</span> <span class="entity">cs</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cs'</span><span class="main">,</span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">prep</span> <span class="entity">cs</span>
      <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> Syntax.check_terms
        <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_schematic <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">cs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">cs'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_autofix</span> <span class="entity">elems</span> <span class="entity">concl</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elem_css</span> <span class="main">=</span> map <span class="entity">extract_elem</span> <span class="entity">elems</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_cs</span> <span class="main">=</span> <span class="main">(</span>map o map<span class="main">)</span> <span class="entity">mk_propp</span> <span class="main">(</span>map snd <span class="entity">concl</span><span class="main">)</span><span class="main">;</span>
    <span class="comment1">(* Type inference *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">css'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>fold_burrow o fold_burrow<span class="main">)</span> <span class="entity">check</span> <span class="main">(</span><span class="entity">elem_css</span> @ <span class="main">[</span><span class="entity">concl_cs</span><span class="main">]</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">elem_css'</span><span class="main">,</span> <span class="entity">concl_cs'</span><span class="main">)</span> <span class="main">=</span> chop <span class="main">(</span>length <span class="entity">elem_css</span><span class="main">)</span> <span class="entity">css'</span> |&gt; apsnd the_single<span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span>map <span class="entity">restore_elem</span> <span class="main">(</span><span class="entity">elems</span> ~~ <span class="entity">elem_css'</span><span class="main">)</span><span class="main">,</span>
      map fst <span class="entity">concl</span> ~~ <span class="entity">concl_cs'</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_stmt</span> <span class="entity">prep_prop</span> <span class="entity">ctxt</span> <span class="entity">stmt</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">stmt</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">Element.Shows</span> <span class="entity">raw_shows</span> <span class="main">=&gt;</span>
      <span class="entity">raw_shows</span> |&gt; <span class="main">(</span>map o apsnd o map<span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ps</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">prep_prop</span> <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_schematic <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span><span class="main">,</span>
          map <span class="main">(</span><span class="entity">prep_prop</span> <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_pattern <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">ps</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">Element.Obtains</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"unsupported"</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parse_elem</span> <span class="entity">prep_typ</span> <span class="entity">prep_term</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="entity">Element.map_ctxt</span>
   <span class="main">{</span>binding <span class="main">=</span> I<span class="main">,</span>
    typ <span class="main">=</span> <span class="entity">prep_typ</span> <span class="entity">ctxt</span><span class="main">,</span>
    term <span class="main">=</span> <span class="entity">prep_term</span> <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_schematic <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
    pattern <span class="main">=</span> <span class="entity">prep_term</span> <span class="main">(</span>Proof_Context.set_mode Proof_Context.mode_pattern <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
    fact <span class="main">=</span> I<span class="main">,</span>
    attrib <span class="main">=</span> I<span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_elem</span> <span class="entity">prep_var</span> <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">prep_var</span> <span class="entity">fixes</span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ctxt</span> |&gt; Proof_Context.add_fixes <span class="entity">vars</span> |&gt; snd <span class="keyword2"><span class="keyword">end</span></span>
  <span class="main">|</span> <span class="entity">declare_elem</span> <span class="entity">prep_var</span> <span class="main">(</span><span class="entity">Element.Constrains</span> <span class="entity">csts</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="entity">ctxt</span> |&gt; fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="entity">prep_var</span> <span class="main">(</span>Binding.name <span class="entity">x</span><span class="main">,</span> SOME <span class="entity">T</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">)</span> <span class="entity">csts</span> |&gt; snd
  <span class="main">|</span> <span class="entity">declare_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Assumes</span> <span class="main">_</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
  <span class="main">|</span> <span class="entity">declare_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Defines</span> <span class="main">_</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
  <span class="main">|</span> <span class="entity">declare_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Notes</span> <span class="main">_</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">ctxt</span>
  <span class="main">|</span> <span class="entity">declare_elem</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Lazy_Notes</span> <span class="main">_</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">ctxt</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_full_context_statement</span>
  <span class="entity">parse_prop</span> <span class="entity">prop_root</span> <span class="entity">elem_root</span> <span class="entity">raw_elems</span> <span class="entity">raw_stmt</span> <span class="entity">ctxt1</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_elem</span> <span class="entity">raw_elem</span> <span class="entity">ctxt</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span>
          |&gt; Context_Position.set_visible false
          |&gt; <span class="entity">declare_elem</span> Proof_Context.read_var <span class="entity">raw_elem</span>
          |&gt; Context_Position.restore_visible <span class="entity">ctxt</span><span class="main">;</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elems'</span> <span class="main">=</span> <span class="entity">parse_elem</span> Syntax.parse_typ <span class="main">(</span><span class="entity">parse_prop</span> <span class="entity">elem_root</span><span class="main">)</span> <span class="entity">ctxt'</span> <span class="entity">raw_elem</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">elems'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fors</span> <span class="main">=</span> fold_map Proof_Context.read_var <span class="main">[</span><span class="main">]</span> <span class="entity">ctxt1</span> |&gt; fst<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt2</span> <span class="main">=</span> <span class="entity">ctxt1</span> |&gt; Proof_Context.add_fixes <span class="entity">fors</span> |&gt; snd<span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt3</span> <span class="main">=</span> <span class="entity">ctxt2</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_stmt</span> <span class="entity">elems</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">check_autofix</span> <span class="entity">elems</span>
      <span class="main">(</span><span class="entity">prepare_stmt</span> <span class="main">(</span><span class="entity">parse_prop</span> <span class="entity">prop_root</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">raw_stmt</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">elems'</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">,</span> <span class="entity">ctxt4</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt3</span>
      |&gt; fold_map <span class="entity">prep_elem</span> <span class="entity">raw_elems</span>
      |-&gt; <span class="entity">prep_stmt</span><span class="main">;</span>

    <span class="comment1">(* parameters from expression and elements *)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xs</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Element.Fixes</span> <span class="entity">fixes</span> <span class="main">=&gt;</span>
      map <span class="main">(</span>Variable.check_name o <span class="main">#</span><span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">fixes</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">Element.Fixes</span> <span class="entity">fors</span> :: <span class="entity">elems'</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">parms</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> fold_map Proof_Context.inferred_param <span class="entity">xs</span> <span class="entity">ctxt4</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">elems''</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">finish_elem</span> <span class="entity">parms</span><span class="main">)</span> <span class="entity">elems'</span><span class="main">;</span>

  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">elems''</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_statement</span> <span class="entity">prop_root</span> <span class="entity">elem_root</span> <span class="entity">raw_elems</span> <span class="entity">raw_stmt</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">elems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_full_context_statement</span>
      <span class="entity">AOT_read_prop</span> <span class="entity">prop_root</span> <span class="entity">elem_root</span> <span class="entity">raw_elems</span> <span class="entity">raw_stmt</span> <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Proof_Context.set_stmt true <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">elems</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">Element.activate</span> <span class="entity">elems</span> <span class="entity">ctxt'</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Proof_Context.restore_stmt <span class="entity">ctxt</span> <span class="entity">ctxt'</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* End of Expression.read_statement variant. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">long_keyword</span> <span class="main">=</span>
  <span class="entity">Parse_Spec.includes</span> &gt;&gt; K <span class="inner_quoted">""</span> ||
  <span class="entity">Parse_Spec.long_statement_keyword</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">long_statement</span> <span class="main">=</span>
  Scan.optional <span class="main">(</span><span class="entity">Parse_Spec.opt_thm_name</span> <span class="inner_quoted">":"</span> --| Scan.ahead <span class="entity">long_keyword</span><span class="main">)</span>
    Binding.empty_atts --
  Scan.optional <span class="entity">Parse_Spec.includes</span> <span class="main">[</span><span class="main">]</span> --<span class="entity">Parse_Spec.long_statement</span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> <span class="entity">includes</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">elems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span>true<span class="main">,</span> <span class="entity">binding</span><span class="main">,</span> <span class="entity">includes</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">short_statement</span> <span class="main">=</span>
  <span class="entity">Parse_Spec.statement</span> -- <span class="entity">Parse_Spec.if_statement</span> -- Parse.for_fixes
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">shows</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span><span class="main">,</span> <span class="entity">fixes</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="main">(</span>false<span class="main">,</span> Binding.empty_atts<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">,</span> <span class="entity">Element.Assumes</span> <span class="entity">assumes</span><span class="main">]</span><span class="main">,</span>
        <span class="entity">Element.Shows</span> <span class="entity">shows</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setupStrictWorld</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="comment1">(* TODO: ideally not just a fixed name, but a variant name... *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Proof_Context.add_fixes
  <span class="main">[</span><span class="main">(</span>Binding.make <span class="main">(</span><span class="inner_quoted">"ws"</span><span class="main">,</span> Position.none<span class="main">)</span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">,</span> Mixfix.NoSyn<span class="main">)</span><span class="main">]</span> <span class="entity">ctxt</span> |&gt;
  apfst the_single
<span class="keyword2"><span class="keyword">in</span></span> AOT_ProofData.put <span class="main">(</span>SOME <span class="main">(</span>Free <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setupWeakWorld</span> <span class="entity">ctxt</span> <span class="main">=</span> AOT_ProofData.put <span class="main">(</span>SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> w<span class="hidden">⇩</span><sub>0</sub><span class="antiquote">}</span></span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapStmt</span> <span class="entity">mapTerm</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Element.Shows</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Element.Shows</span> <span class="main">(</span>map <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">trm</span><span class="main">,</span> <span class="entity">trms</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="main">(</span><span class="entity">mapTerm</span> <span class="entity">trm</span><span class="main">,</span> map <span class="entity">mapTerm</span> <span class="entity">trms</span><span class="main">)</span><span class="main">)</span> |&gt; apsnd<span class="main">)</span> <span class="entity">x</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">mapStmt</span> <span class="entity">mapTerm</span> <span class="entity">mapTyp</span> <span class="main">(</span><span class="entity">Element.Obtains</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Element.Obtains</span> <span class="main">(</span>map <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> Option.map <span class="entity">mapTyp</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="entity">x</span><span class="main">,</span> map <span class="entity">mapTerm</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> |&gt; apsnd<span class="main">)</span> <span class="entity">x</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapCtxt</span> <span class="entity">mapTerm</span> <span class="entity">mapTyp</span> <span class="entity">ctxtElem</span> <span class="main">=</span> <span class="entity">Element.map_ctxt</span>
  <span class="main">{</span>attrib <span class="main">=</span> I<span class="main">,</span> binding <span class="main">=</span> I<span class="main">,</span> fact <span class="main">=</span> I<span class="main">,</span> pattern <span class="main">=</span> <span class="entity">mapTerm</span><span class="main">,</span> term <span class="main">=</span> <span class="entity">mapTerm</span><span class="main">,</span> typ <span class="main">=</span> <span class="entity">mapTyp</span><span class="main">}</span>
  <span class="entity">ctxtElem</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_theorem_cmd</span> <span class="entity">axiom</span> <span class="entity">modallyStrict</span> <span class="entity">long</span> <span class="entity">afterQed</span> <span class="entity">thmBinding</span>
  <span class="entity">includes</span> <span class="entity">assumptions</span> <span class="entity">shows</span> <span class="entity">int</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Bundle.includes_cmd</span> <span class="entity">includes</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">modallyStrict</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">setupStrictWorld</span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">setupWeakWorld</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">root</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">axiom</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">modallyStrict</span>
            <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> "AOT_axiom"<span class="antiquote">}</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> "AOT_act_axiom"<span class="antiquote">}</span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">stmts</span><span class="main">,</span><span class="entity">assumptions</span><span class="main">,</span><span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_statement</span>
      <span class="entity">root</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span> <span class="entity">assumptions</span> <span class="entity">shows</span> <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_print_item_number</span> <span class="main">(</span>Binding.name_of <span class="main">(</span>fst <span class="entity">thmBinding</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">bnd</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
      <span class="entity">AOT_print_item_number</span> <span class="main">(</span>Binding.name_of <span class="entity">bnd</span><span class="main">)</span><span class="main">)</span> <span class="entity">stmts</span> <span class="main">(</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Specification.theorem</span> <span class="entity">long</span> <span class="inner_quoted">"AOT_theorem"</span> NONE <span class="entity">afterQed</span> <span class="entity">thmBinding</span> <span class="main">[</span><span class="main">]</span>
      <span class="entity">assumptions</span> <span class="main">(</span><span class="entity">Element.Shows</span> <span class="entity">stmts</span><span class="main">)</span> <span class="entity">int</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">AOT_theorem</span> <span class="entity">spec</span> <span class="entity">note</span> <span class="entity">axiom</span> <span class="entity">modallyStrict</span> <span class="entity">descr</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory_to_proof'</span> <span class="entity">spec</span> <span class="main">(</span><span class="inner_quoted">"state "</span> ^ <span class="entity">descr</span><span class="main">)</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">long_statement</span> || <span class="entity">short_statement</span><span class="main">)</span> &gt;&gt;
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">long</span><span class="main">,</span> <span class="entity">binding</span><span class="main">,</span> <span class="entity">includes</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">AOT_theorem_cmd</span> <span class="entity">axiom</span> <span class="entity">modallyStrict</span> <span class="entity">long</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">note</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">AOT_note_theorems</span> <span class="keyword2"><span class="keyword">else</span></span> K I<span class="main">)</span> <span class="entity">binding</span> <span class="entity">includes</span> <span class="entity">elems</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_lemma</span>›</span></span> false false true
  <span class="inner_quoted">"AOT modally-strict lemma"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_theorem</span>›</span></span> true false true
  <span class="inner_quoted">"AOT modally-strict theorem"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_act_lemma</span>›</span></span> false false false
  <span class="inner_quoted">"AOT modally-weak lemma"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_act_theorem</span>›</span></span> true false false
  <span class="inner_quoted">"AOT modally-weak theorem"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_axiom</span>›</span></span> true true true
  <span class="inner_quoted">"AOT modally-strict axiom"</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">AOT_theorem</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_act_axiom</span>›</span></span> true true false
  <span class="inner_quoted">"AOT modally-weak axiom"</span>

<span class="keyword2"><span class="keyword">local</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">structured_statement</span> <span class="main">=</span>
  <span class="entity">Parse_Spec.statement</span> -- <span class="entity">Parse_Spec.if_statement</span> -- Parse.for_fixes
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">shows</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span><span class="main">,</span> <span class="entity">fixes</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">shows</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_stmt</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">shows</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">elems</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">read_statement</span>
    <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span>
    <span class="main">[</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">,</span> <span class="entity">Element.Assumes</span> <span class="entity">assumes</span><span class="main">]</span> <span class="main">(</span><span class="entity">Element.Shows</span> <span class="entity">shows</span><span class="main">)</span> <span class="entity">ctxt</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">Element.Fixes</span> <span class="entity">fixes</span><span class="main">,</span> <span class="entity">Element.Assumes</span> <span class="entity">assumes</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unexpected."</span><span class="main">)</span> <span class="entity">elems</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapAttr</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">mapAttr</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match <span class="comment1">(* Unimplemented *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assumes</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mapAttr</span> |&gt; apfst<span class="main">)</span> <span class="entity">assumes</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mapAttr</span> |&gt; apfst<span class="main">)</span> <span class="entity">concl</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_cmd</span> <span class="entity">kind</span> <span class="entity">stmt</span> <span class="entity">int</span> <span class="entity">state</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">shows</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_stmt</span> <span class="entity">stmt</span> <span class="main">(</span><span class="entity">Proof.context_of</span> <span class="entity">state</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">kind</span> true NONE <span class="main">(</span>K I<span class="main">)</span> <span class="entity">fixes</span> <span class="entity">assumes</span> <span class="entity">shows</span> <span class="entity">int</span><span class="main">)</span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_show</span>›</span></span>
    <span class="inner_quoted">"state local AOT goal, to refine pending subgoals"</span>
    <span class="main">(</span><span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">stmt</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.proof'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">int</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">gen_cmd</span> <span class="entity">Proof.show</span> <span class="entity">stmt</span> <span class="entity">int</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_thus</span>›</span></span> <span class="inner_quoted">"alias of  \"then AOT_show\""</span>
    <span class="main">(</span><span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">stmt</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.proof'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">int</span> <span class="main">=&gt;</span> <span class="entity">Proof.chain</span> #&gt; <span class="main">(</span><span class="entity">gen_cmd</span> <span class="entity">Proof.show</span> <span class="entity">stmt</span> <span class="entity">int</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_have</span>›</span></span> <span class="inner_quoted">"state local AOT goal"</span>
    <span class="main">(</span><span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">stmt</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.proof'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">int</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">gen_cmd</span> <span class="entity">Proof.have</span> <span class="entity">stmt</span> <span class="entity">int</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_hence</span>›</span></span> <span class="inner_quoted">"alias of  \"then AOT_have\""</span>
    <span class="main">(</span><span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">stmt</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.proof'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">int</span> <span class="main">=&gt;</span> <span class="entity">Proof.chain</span> #&gt; <span class="main">(</span><span class="entity">gen_cmd</span> <span class="entity">Proof.have</span> <span class="entity">stmt</span> <span class="entity">int</span> #&gt; <span class="main">#</span><span class="inner_numeral">2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_modally_strict {</span>›</span></span>
    <span class="inner_quoted">"begin explicit AOT modally-strict proof block"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">Proof.map_context</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">v</span> <span class="main">=</span> singleton <span class="main">(</span>Variable.variant_frees <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="inner_quoted">"ws"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">)</span> |&gt; fst
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Proof_Context.add_fixes
          <span class="main">[</span><span class="main">(</span>Binding.make <span class="main">(</span><span class="entity">v</span><span class="main">,</span> Position.none<span class="main">)</span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">,</span> Mixfix.NoSyn<span class="main">)</span><span class="main">]</span> <span class="entity">ctxt</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> AOT_ProofData.put <span class="main">(</span>SOME <span class="main">(</span>Free <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">Proof.begin_block</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_actually {</span>›</span></span>
    <span class="inner_quoted">"begin explicit AOT modally-fragile proof block"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">Proof.map_context</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> AOT_ProofData.put <span class="main">(</span>SOME <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> w<span class="hidden">⇩</span><sub>0</sub><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="main">(</span><span class="entity">Proof.begin_block</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_assume</span>›</span></span> <span class="inner_quoted">"assume AOT propositions"</span>
    <span class="main">(</span><span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">stmt</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.proof'</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">shows</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_stmt</span> <span class="entity">stmt</span> <span class="main">(</span><span class="entity">Proof.context_of</span> <span class="entity">state</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">Proof.assume</span> <span class="entity">fixes</span> <span class="main">(</span>map snd <span class="entity">assumes</span><span class="main">)</span> <span class="entity">shows</span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_obtain</span>›</span></span> <span class="inner_quoted">"generalized AOT elimination"</span>
    <span class="main">(</span>Parse.parbinding -- Scan.optional <span class="main">(</span>Parse.vars --| Parse.where_<span class="main">)</span> <span class="main">[</span><span class="main">]</span> --
      <span class="entity">structured_statement</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span><span class="main">,</span> <span class="entity">stmt</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Toplevel.proof'</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">int</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Proof.context_of</span> <span class="entity">state</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">b</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="entity">b</span><span class="main">,</span><span class="entity">c</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span>Option.map <span class="main">(</span>Syntax.read_typ <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="entity">b</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bnds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">a</span><span class="main">)</span> <span class="entity">b</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span> Variable.add_fixes_binding <span class="entity">bnds</span> <span class="entity">ctxt</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fixes</span><span class="main">,</span> <span class="entity">assumes</span><span class="main">,</span> <span class="entity">shows</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prep_stmt</span> <span class="entity">stmt</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">Obtain.obtain</span> <span class="entity">a</span> <span class="entity">b</span> <span class="entity">fixes</span> <span class="main">(</span>map snd <span class="entity">assumes</span><span class="main">)</span> <span class="entity">shows</span> <span class="entity">int</span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">thm_name</span>›</span></span> <span class="inner_quoted">"print theorems"</span>
    <span class="main">(</span>Parse.thms1 &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">thms</span> <span class="main">=&gt;</span> <span class="entity">Toplevel.keep</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Toplevel.context_of</span> <span class="entity">state</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thms</span> <span class="main">=</span> <span class="entity">Attrib.eval_thms</span> <span class="entity">ctxt</span> <span class="entity">thms</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trms</span> <span class="main">=</span> map Thm.full_prop_of <span class="entity">thms</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">trm</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> <span class="entity">Find_Theorems.find_theorems</span> <span class="entity">ctxt</span> NONE NONE true
  <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Find_Theorems.Pattern</span> <span class="entity">trm</span><span class="main">)</span><span class="main">]</span> |&gt; snd
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span>Pretty.writeln o <span class="entity">Find_Theorems.pretty_thm</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">result</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="entity">result</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">trms</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">strs</span> <span class="main">=</span> map <span class="main">(</span>Long_Name.base_name o Facts.ref_name o fst<span class="main">)</span> <span class="entity">result</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Pretty.writeln <span class="main">(</span>Pretty.enum <span class="inner_quoted">""</span> <span class="inner_quoted">""</span> <span class="inner_quoted">""</span> <span class="main">(</span>map Pretty.str <span class="entity">strs</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AOT_no_atp</span> <span class="main">=</span> <span class="entity">Named_Thms</span><span class="main">(</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "AOT_no_atp"<span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">description</span> <span class="main">=</span> <span class="inner_quoted">"AOT Theorem Blacklist"</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_sledgehammer</span>›</span></span>
    <span class="inner_quoted">"sledgehammer restricted to AOT abstraction layer"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.keep_proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> <span class="entity">Sledgehammer_Commands.default_params</span> <span class="main">(</span><span class="entity">Toplevel.theory_of</span> <span class="entity">state</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Toplevel.context_of</span> <span class="entity">state</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_facts_of</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer</span> <span class="main">=</span> Global_Theory.transfer_theories <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">global_facts</span> <span class="main">=</span> Global_Theory.facts_of <span class="entity">thy</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">(</span>Facts.dest_all <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">global_facts</span>
   |&gt; maps Facts.selections
   |&gt; map <span class="main">(</span>apsnd <span class="entity">transfer</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">facts</span> <span class="main">=</span> <span class="entity">all_facts_of</span> <span class="entity">ctxt</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_facts</span> <span class="main">=</span> filter
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fact</span> <span class="main">=&gt;</span> <span class="entity">AOT_Theorems.member</span> <span class="entity">ctxt</span> <span class="main">(</span>snd <span class="entity">fact</span><span class="main">)</span><span class="main">)</span> <span class="entity">facts</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">del_facts</span> <span class="main">=</span> filter
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fact</span> <span class="main">=&gt;</span> <span class="entity">AOT_no_atp.member</span> <span class="entity">ctxt</span> <span class="main">(</span>snd <span class="entity">fact</span><span class="main">)</span><span class="main">)</span> <span class="entity">facts</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Toplevel.proof_of</span> <span class="entity">state</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Sledgehammer.run_sledgehammer</span> <span class="entity">params</span> <span class="entity">Sledgehammer_Prover.Normal</span> NONE <span class="inner_numeral">1</span>
  <span class="main">{</span>add <span class="main">=</span> <span class="entity">add_facts</span><span class="main">,</span> del <span class="main">=</span> <span class="entity">del_facts</span><span class="main">,</span> only <span class="main">=</span> false<span class="main">}</span> <span class="entity">ctxt</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_sledgehammer_only</span>›</span></span>
    <span class="inner_quoted">"sledgehammer restricted to AOT abstraction layer"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.keep_proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">params</span> <span class="main">=</span> <span class="entity">Sledgehammer_Commands.default_params</span> <span class="main">(</span><span class="entity">Toplevel.theory_of</span> <span class="entity">state</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Toplevel.context_of</span> <span class="entity">state</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_facts_of</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer</span> <span class="main">=</span> Global_Theory.transfer_theories <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">local_facts</span> <span class="main">=</span> Proof_Context.facts_of <span class="entity">ctxt</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">global_facts</span> <span class="main">=</span> Global_Theory.facts_of <span class="entity">thy</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">(</span>Facts.dest_all <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span> false <span class="main">[</span><span class="entity">global_facts</span><span class="main">]</span> <span class="entity">local_facts</span> 
   |&gt; maps Facts.selections
   |&gt; map <span class="main">(</span>apsnd <span class="entity">transfer</span><span class="main">)</span> |&gt; map fst<span class="main">)</span> @
   <span class="main">(</span>Facts.dest_all <span class="main">(</span>Context.Proof <span class="entity">ctxt</span><span class="main">)</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">global_facts</span>
   |&gt; maps Facts.selections
   |&gt; map <span class="main">(</span>apsnd <span class="entity">transfer</span><span class="main">)</span>
   |&gt; filter <span class="main">(</span><span class="entity">AOT_Theorems.member</span> <span class="entity">ctxt</span> o snd<span class="main">)</span> |&gt; map fst<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">facts</span> <span class="main">=</span> <span class="entity">all_facts_of</span> <span class="entity">ctxt</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">facts</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="entity">Toplevel.proof_of</span> <span class="entity">state</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">Sledgehammer.run_sledgehammer</span> <span class="entity">params</span> <span class="entity">Sledgehammer_Prover.Normal</span> NONE <span class="inner_numeral">1</span>
  <span class="main">{</span>add <span class="main">=</span> <span class="entity">result</span><span class="main">,</span> del <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> only <span class="main">=</span> true<span class="main">}</span> <span class="entity">ctxt</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">readTermPattern</span> <span class="entity">ctxt</span> <span class="entity">str</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> try <span class="main">(</span><span class="entity">AOT_read_term</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> τ'<span class="antiquote">}</span></span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">str</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span>
              <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> try <span class="main">(</span><span class="entity">AOT_read_term</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> φ'<span class="antiquote">}</span></span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">str</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">x</span> <span class="main">=&gt;</span> <span class="entity">x</span>
               <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">AOT_read_term</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">nonterminal</span> AOT_prop<span class="antiquote">}</span></span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">str</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Syntax.check_term <span class="entity">ctxt</span> <span class="entity">trm</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">varifyTerm</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span>‹AOT_term_of_var›</span><span class="main">,</span> Type <span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> $
                  Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">varifyTerm</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">varifyTerm</span> <span class="main">(</span><span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">varifyTerm</span> <span class="entity">x</span> $ <span class="entity">varifyTerm</span> <span class="entity">y</span>
    <span class="main">|</span> <span class="entity">varifyTerm</span> <span class="main">(</span>Abs <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Abs<span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">varifyTerm</span> <span class="entity">c</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">varifyTerm</span> <span class="entity">z</span> <span class="main">=</span> <span class="entity">z</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> Term.map_types
    <span class="main">(</span>Term.map_type_tfree <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span><span class="entity">sort</span><span class="main">)</span> <span class="main">=&gt;</span> TVar <span class="main">(</span><span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">trm</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trm</span> <span class="main">=</span> <span class="entity">varifyTerm</span> <span class="entity">trm</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">parseCriterion</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Find_Theorems.Simp</span> <span class="entity">crit</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">Find_Theorems.Simp</span> <span class="main">(</span><span class="entity">readTermPattern</span> <span class="entity">ctxt</span> <span class="entity">crit</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Find_Theorems.Pattern</span> <span class="entity">crit</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">Find_Theorems.Pattern</span> <span class="main">(</span><span class="entity">readTermPattern</span> <span class="entity">ctxt</span> <span class="entity">crit</span><span class="main">)</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="main">_</span> <span class="main">(</span><span class="entity">Find_Theorems.Name</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Find_Theorems.Name</span> <span class="entity">x</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="main">_</span> <span class="entity">Find_Theorems.Intro</span> <span class="main">=</span> <span class="entity">Find_Theorems.Intro</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="main">_</span> <span class="entity">Find_Theorems.Elim</span> <span class="main">=</span> <span class="entity">Find_Theorems.Elim</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="main">_</span> <span class="entity">Find_Theorems.Dest</span> <span class="main">=</span> <span class="entity">Find_Theorems.Dest</span>
  <span class="main">|</span> <span class="entity">parseCriterion</span> <span class="main">_</span> <span class="entity">Find_Theorems.Solves</span> <span class="main">=</span> <span class="entity">Find_Theorems.Solves</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_criterion</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfx</span> <span class="entity">s</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"-"</span> ^ <span class="entity">s</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">Find_Theorems.Name</span> <span class="entity">name</span> <span class="main">=&gt;</span> Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"name: "</span> ^ quote <span class="entity">name</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Intro</span> <span class="main">=&gt;</span> Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"intro"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Elim</span> <span class="main">=&gt;</span> Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"elim"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Dest</span> <span class="main">=&gt;</span> Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"dest"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Solves</span> <span class="main">=&gt;</span> Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"solves"</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Simp</span> <span class="entity">pat</span> <span class="main">=&gt;</span> Pretty.block <span class="main">[</span>Pretty.str <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"simp:"</span><span class="main">)</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">,</span>
        Pretty.quote <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Term.show_dummy_patterns <span class="entity">pat</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
    <span class="main">|</span> <span class="entity">Find_Theorems.Pattern</span> <span class="entity">pat</span> <span class="main">=&gt;</span> Pretty.enclose <span class="main">(</span><span class="entity">prfx</span> <span class="inner_quoted">"\""</span><span class="main">)</span> <span class="inner_quoted">"\""</span>
        <span class="main">[</span>Syntax.pretty_term <span class="entity">ctxt</span> <span class="main">(</span>Term.show_dummy_patterns <span class="entity">pat</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">query</span> <span class="main">=</span> <span class="entity">Criterion</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>bool*string Find_Theorems.criterion<span class="main">)</span> list <span class="main">|</span>
                 <span class="entity">Item</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>int*string list<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_theorems</span> <span class="entity">ctxt</span> <span class="entity">opt_lim</span> <span class="entity">rem_dups</span> <span class="entity">raw_spec</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_ref</span> <span class="entity">ctxt</span> <span class="entity">thmref</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">thmref</span> <span class="keyword2"><span class="keyword">of</span></span>
          Facts.Named <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">sel</span><span class="main">)</span>
        <span class="main">|</span> Facts.Fact <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Illegal literal fact"</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span>
        <span class="entity">AOT_get_item_number</span> <span class="main">(</span>Binding.name_of <span class="main">(</span>Binding.qualified_name <span class="entity">name</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">str</span> <span class="main">=&gt;</span> <span class="main">[</span>Pretty.str <span class="main">(</span><span class="inner_quoted">"("</span>^<span class="entity">str</span>^<span class="inner_quoted">")"</span><span class="main">)</span><span class="main">,</span> Pretty.str <span class="inner_quoted">":"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">item</span> @ <span class="main">[</span>Pretty.marks_str <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="main">(</span>Proof_Context.markup_extern_fact <span class="entity">ctxt</span> <span class="entity">name</span><span class="main">)</span><span class="main">,</span> <span class="entity">name</span><span class="main">)</span><span class="main">,</span>
        Pretty.str <span class="main">(</span>Facts.string_of_selection <span class="entity">sel</span><span class="main">)</span><span class="main">,</span> Pretty.str <span class="inner_quoted">":"</span><span class="main">,</span> Pretty.brk <span class="inner_numeral">1</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tailToStr</span> <span class="entity">delim</span> <span class="entity">tail</span> <span class="main">=</span> <span class="main">(</span>fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">field</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str</span> <span class="main">=&gt;</span> <span class="entity">str</span>^<span class="entity">delim</span>^<span class="entity">field</span><span class="main">)</span> <span class="entity">tail</span> <span class="inner_quoted">""</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_item</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">sub</span><span class="main">)</span> <span class="main">=</span> Pretty.str <span class="main">(</span>
    <span class="inner_quoted">"item: "</span>^quote <span class="main">(</span>Int.toString <span class="entity">id</span>^<span class="entity">tailToStr</span> <span class="inner_quoted">"."</span> <span class="entity">sub</span><span class="main">)</span>^
    <span class="inner_quoted">" (name: "</span>^quote <span class="main">(</span><span class="main">(</span>the <span class="main">(</span><span class="entity">AOT_name_of_item</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span>^<span class="entity">tailToStr</span> <span class="inner_quoted">":"</span> <span class="entity">sub</span><span class="main">)</span>^<span class="inner_quoted">")"</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">thmref</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span>
    Pretty.block <span class="main">(</span><span class="entity">pretty_ref</span> <span class="entity">ctxt</span> <span class="entity">thmref</span> @ <span class="main">[</span>Thm.pretty_thm <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">]</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">spec</span><span class="main">,</span> <span class="entity">prefix</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_spec</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Item</span> <span class="main">(</span><span class="entity">item</span><span class="main">,</span> <span class="entity">tail</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">AOT_name_of_item</span> <span class="entity">item</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">name</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fullName</span> <span class="main">=</span> <span class="entity">name</span>^<span class="entity">tailToStr</span> <span class="inner_quoted">":"</span> <span class="entity">tail</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="entity">Find_Theorems.Name</span> <span class="entity">fullName</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> SOME <span class="entity">fullName</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
          <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Unknown PLM item number."</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Criterion</span> <span class="entity">spec</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">spec</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">criteria</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">parseCriterion</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">spec</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">opt_found</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Find_Theorems.find_theorems</span> <span class="entity">ctxt</span> NONE <span class="main">(</span>SOME <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">rem_dups</span> <span class="entity">criteria</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">theorems</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Find_Theorems.find_theorems</span> <span class="entity">ctxt</span> NONE <span class="entity">opt_found</span> <span class="entity">rem_dups</span> <span class="entity">criteria</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lim</span> <span class="main">=</span> the_default
    <span class="main">(</span>Options.default_int <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">system_option</span><span class="hidden">&gt;</span></span>‹find_theorems_limit›</span></span><span class="main">)</span> <span class="entity">opt_lim</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">theorems</span> <span class="main">=</span> filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">thm</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">AOT_Theorems.member</span> <span class="entity">ctxt</span> <span class="entity">thm</span><span class="main">)</span> <span class="entity">theorems</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">theorems</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">prefix</span> <span class="keyword2"><span class="keyword">of</span></span> SOME <span class="entity">prefix</span> <span class="main">=&gt;</span>
    filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span>Facts.Named <span class="main">(</span><span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unqualified</span> <span class="main">=</span> <span class="main">(</span>Binding.name_of <span class="main">(</span>Binding.qualified_name <span class="entity">name</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
      String.isPrefix <span class="entity">prefix</span> <span class="entity">unqualified</span>
      <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span>String.size <span class="entity">unqualified</span> &lt;= String.size <span class="entity">prefix</span> <span class="keyword1"><span class="keyword">orelse</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">delim</span> <span class="main">=</span> String.sub <span class="main">(</span><span class="entity">unqualified</span><span class="main">,</span> String.size <span class="entity">prefix</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">delim</span> <span class="main">=</span> <span class="inner_quoted">#":"</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">delim</span> <span class="main">=</span> <span class="inner_quoted">#"["</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span> <span class="entity">theorems</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">theorems</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">found</span> <span class="main">=</span> length <span class="entity">theorems</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">theorems</span> <span class="main">=</span> drop <span class="main">(</span>Int.max <span class="main">(</span><span class="entity">found</span> - <span class="entity">lim</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">)</span> <span class="entity">theorems</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">returned</span> <span class="main">=</span> length <span class="entity">theorems</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tally_msg</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">found</span> &lt;= <span class="entity">lim</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"displaying "</span> ^ string_of_int <span class="entity">returned</span> ^ <span class="inner_quoted">" theorem(s)"</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"found "</span> ^ string_of_int <span class="entity">found</span> ^ <span class="inner_quoted">" theorem(s)"</span> ^
            <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">returned</span> &lt; <span class="entity">found</span>
             <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">" ("</span> ^ string_of_int <span class="entity">returned</span> ^ <span class="inner_quoted">" displayed)"</span>
             <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">position_markup</span> <span class="main">=</span> Position.markup <span class="main">(</span>Position.thread_data <span class="main">(</span><span class="main">)</span><span class="main">)</span> Markup.position<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pretty</span> <span class="main">=</span> Pretty.block
        <span class="main">(</span>Pretty.fbreaks
          <span class="main">(</span>Pretty.mark <span class="entity">position_markup</span> <span class="main">(</span>Pretty.keyword1 <span class="inner_quoted">"AOT_find_theorems"</span><span class="main">)</span> ::
            <span class="main">(</span><span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_spec</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Item</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">sub</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="main">[</span><span class="entity">pretty_item</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">sub</span><span class="main">)</span><span class="main">]</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="entity">pretty_criterion</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">criteria</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> ::
    Pretty.str <span class="inner_quoted">""</span> ::
    <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">theorems</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span>Pretty.str <span class="inner_quoted">"found nothing"</span><span class="main">]</span>
     <span class="keyword2"><span class="keyword">else</span></span>
       Pretty.str <span class="main">(</span><span class="entity">tally_msg</span> ^ <span class="inner_quoted">":"</span><span class="main">)</span> ::
       grouped <span class="inner_numeral">10</span> Par_List.map <span class="main">(</span>Pretty.item o single o <span class="entity">pretty_thm</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>rev <span class="entity">theorems</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="entity">pretty</span> |&gt; Pretty.fbreaks |&gt; curry Pretty.blk <span class="inner_numeral">0</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">options</span> <span class="main">=</span>
  Scan.optional
    <span class="main">(</span>Parse.$$$ <span class="inner_quoted">"("</span> |--
      Parse.!!! <span class="main">(</span>Scan.option Parse.nat --
        Scan.optional <span class="main">(</span>Parse.reserved <span class="inner_quoted">"with_dups"</span> &gt;&gt; K false<span class="main">)</span> true --| Parse.$$$ <span class="inner_quoted">")"</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>NONE<span class="main">,</span> true<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item_parser</span> <span class="main">=</span> <span class="main">(</span>Parse.nat &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span><span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>  || <span class="main">(</span>Parse.string &gt;&gt; <span class="main">(</span>
  <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">str</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fields</span> <span class="main">=</span> String.fields <span class="main">(</span>equal <span class="inner_quoted">#"."</span><span class="main">)</span> <span class="entity">str</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>Int.fromString <span class="main">(</span>hd <span class="entity">fields</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>SOME <span class="entity">n</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">n</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_numeral">0</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> tl <span class="entity">fields</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span> <span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">query_parser</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span>Parse.reserved <span class="inner_quoted">"item"</span> |-- Parse.!!! <span class="main">(</span>Parse.$$$ <span class="inner_quoted">":"</span> |-- <span class="entity">item_parser</span><span class="main">)</span> &gt;&gt; <span class="entity">Item</span><span class="main">)</span> ||
  <span class="main">(</span><span class="entity">Find_Theorems.query_parser</span> &gt;&gt; <span class="entity">Criterion</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_theorems</span> <span class="main">(</span><span class="main">(</span><span class="entity">opt_lim</span><span class="main">,</span> <span class="entity">rem_dups</span><span class="main">)</span><span class="main">,</span> <span class="entity">spec</span><span class="main">)</span> <span class="entity">st</span> <span class="main">=</span>
     <span class="main">(</span>Pretty.writeln
            <span class="main">(</span><span class="entity">pretty_theorems</span> <span class="main">(</span>AOT_ProofData.put <span class="main">(</span>SOME <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"ws"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">w</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                              <span class="main">(</span><span class="entity">Proof.context_of</span> <span class="main">(</span><span class="entity">Find_Theorems.proof_state</span> <span class="entity">st</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                             <span class="entity">opt_lim</span> <span class="entity">rem_dups</span> <span class="entity">spec</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">in</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">AOT_find_theorems</span>›</span></span>
    <span class="inner_quoted">"find theorems meeting specified criteria"</span>
    <span class="main">(</span><span class="entity">options</span> -- <span class="entity">query_parser</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">query</span> <span class="main">=&gt;</span>
      <span class="entity">Toplevel.keep</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">st</span> <span class="main">=&gt;</span> <span class="entity">find_theorems</span> <span class="entity">query</span> <span class="entity">st</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setup_AOT_no_atp</span> <span class="entity">thy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_facts_with_AOT_semantics</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer</span> <span class="main">=</span> Global_Theory.transfer_theories <span class="entity">thy</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">global_facts</span> <span class="main">=</span> Global_Theory.facts_of <span class="entity">thy</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">(</span>Facts.dest_all <span class="main">(</span>Context.Theory <span class="entity">thy</span><span class="main">)</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">global_facts</span>
   |&gt; maps Facts.selections
   |&gt; map <span class="main">(</span>apsnd <span class="entity">transfer</span><span class="main">)</span>
   |&gt; filter <span class="main">(</span>not o <span class="entity">AOT_Theorems.member</span> <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> o snd<span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_facts_Main</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transfer</span> <span class="main">=</span> Global_Theory.transfer_theories <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span> <a href="../../HOL/HOL/Main.html">Main</a><span class="antiquote">}</span></span></span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">global_facts</span> <span class="main">=</span> Global_Theory.facts_of <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span> <a href="../../HOL/HOL/Main.html">Main</a><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
   <span class="main">(</span>Facts.dest_all <span class="main">(</span>Context.Theory <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span> <a href="../../HOL/HOL/Main.html">Main</a><span class="antiquote">}</span></span></span><span class="main">)</span> false <span class="main">[</span><span class="main">]</span> <span class="entity">global_facts</span>
   |&gt; maps Facts.selections
   |&gt; map <span class="main">(</span>apsnd <span class="entity">transfer</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">facts</span> <span class="main">=</span> filter
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">elem</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> not <span class="main">(</span>List.exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">elem'</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">elem</span> <span class="main">=</span> <span class="entity">elem'</span><span class="main">)</span> <span class="entity">all_facts_Main</span><span class="main">)</span><span class="main">)</span>
  <span class="entity">all_facts_with_AOT_semantics</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> fold
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fact</span> <span class="main">=&gt;</span> Context.theory_map <span class="main">(</span><span class="entity">AOT_no_atp.add_thm</span> <span class="entity">fact</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span>map snd <span class="entity">facts</span><span class="main">)</span> <span class="entity">thy</span>
<span class="keyword2"><span class="keyword">in</span></span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">end</span></span>
</pre>
</body>

</html>